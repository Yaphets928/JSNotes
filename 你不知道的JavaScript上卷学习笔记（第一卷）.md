# Ch1 作用域
javascript语言的编译发生在代码执行前的几微秒，  
js引擎使用各种办法（如JIT，可以延迟编译甚至实施重编译）来保证性能。  
### 理解作用域
>var a = 2;的过程：  
1.编译器在当前作用域声明一个变量（之前没有声明过）；  
2.运行时引擎在作用域查找该变量，找到就赋值，找不到就抛出异常。  

>LHS查询和RHS查询  
L和R是一个赋值操作的左侧和非左侧，即变量出现在左侧用LHS查询，右侧用RHS  
RHS与简单查找某个变量的值没有u区别  
LHS查询则是试图找到容器本身，再对其赋值  
LHS：赋值操作的目标是谁  
RHS：谁是赋值操作的源头

```
function foo(a){
    var b = a;
    return a+b;
}
var c = foo( 2 );
```
这段代码进行了3处LHS：c= ，a= ，b=  
　　　　　　　4处RHS：找foo，=a，a+b（两次）  
  
>作用域链：本作用域找不到去上层找  

>为什么要区分LHS和RHS？
对未声明的变量（即任何作用域都没有的）是不同的  
RHS查不到变量抛出ReferenceError  
LHS查不到变量就会创建一个全局变量返还给引擎  
严格模式下禁止自动或隐式地创建全局变量，查询失败同样抛出ReferenceError异常  

>如果RHS查询到了，但是正在进行不合理的操作（如对非函数类型进行函数调用或引用null或undefined的值的属性，则抛出异常TypeError  

>RefferenceError和作用于判别失败有关  
TypeError代表作用域判别成功了，但是对结果的操作是非法的。  

### 小结  
作用域是个规则，查找的目的是赋值，就用LHS查询，查找的目的是获取值，就用RHS查询。赋值会导致LHS查询。=操作符或调用函数时的操作都会导致关联作用域的赋值操作。

# Ch2 词法作用域  
作用域的分类：
- 词法作用域
- 动态作用域   

>编译器的第一个工作：词法化：字符串组成的代码分解为有意义的代码块  
var a = 2；分解为 var，a，=，2，；  空格取决于语言  
词法作用域就是定义在词法化阶段的作用域  
由写代码时将变量和作用域写在哪里决定的  
作用域查找找到第一个匹配的停止  
词法作用域只查一级标识符 如a.b.c.d，只找a，找到后对象属性访问规则接管对bcd的访问  

### 欺骗词法  
>性能会下降  引擎无法在编译时对作用域查找进行优化
#### eval  
>使用eval时引擎并不知道这段代码是以动态形式插入的，不会对词法作用域的环境修改，eval()中的代码会被当作本来就在那里一样  
eval通常被用来执行动态创建的代码，将字符串拼接在一起之后再传进去。  
严格模式下eval运行时有自己的词法作用域，意味着其中的声明无法修改所在的作用域。
#### with
>通常用作重复引用同一对象的多个属性的快捷方式  
with将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，对这个对象的属性也会被处理为定义在这个作用域中的词法标识符。  
with内部的var声明不会被限制在这个块的作用域中，而是被添加到with所处的函数作用域中。
eval函数如果接受了声明代码，会修改其词法作用域  
with声明实际上是根据你传递给他的对象凭空创建了一个新词法域  

严格模式限制with和eval

# Ch3 函数作用域和块作用域
>最小授权，最小暴露原则：软件设计中，最小限度地暴露必要内容。

>区分函数声明与函数表达式：function是第一个词，就是声明，否则就是函数表达式。  
函数声明function foo(){}的foo绑定在所在作用域中  
函数表达式(function foo(){..})()；foo只能..中访问，外部作用域不可以  
函数声明必须具名  
函数表达式可以匿名  

>IIFE：Immediately Invoked Function Expression  
(function(){})()  
IIFE进阶用法，当作函数调用并传参：
```
(function IIFE(global){
    
})(window);
```
解决undefined标识符默认值被人覆盖的情况：
```
undefined = true;//挖坑
(function IIFE(undefined){
    var a;
    if(a === undefined){
        console.log("a = undefined?")
    }
})()
//这种情况下，将一个参数命名为undefined，但是对应位置不传参。
```

>ES5及之前的块作用域  
with  
try-catch中的catch分句会创建一个块作用域  

>ES6的块作用域
let 作用域只对最内侧块有效  
var 范围至少是一个函数内  
let进行的声明不会提升  

>块作用域优化垃圾收集，将在闭包中详细讲解  
let用于循环，是将至重新绑定到了循环的每一个迭代中  

# CH4 提升  
>引擎会在解释js代码钱先编译  
编译会找到所有的声明，并用合适的作用域关联起来  
var a=2;被拆分成了var a和a = 2  第一个是编译阶段，第二个是执行阶段  
只有声明会提升，赋值不会。  
每个作用域都会进行提升操作  
函数声明function(){}会提升，函数表达式不会  
```
foo();
var foo=function bar(){
    
};
//这里是TypeError！不是ReferenceError
//foo标识符会被提升，但是赋值不会，foo()属于对undefined值进行了函数调用
```
```
foo();//TypeError
bar();//ReferenceError
var foo = function bar(){
    
};//即使是具名的函数表达式，在赋值前也不能操作
```
>函数首先提升，然后是变量。

# Ch5 闭包  
>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。
```
function foo(){
    var a = 2;
    function bar(){
        console.log( a );
    }
    return bar;
}
var baz = foo();
baz();//输出2 这就是闭包
```
>函数bar的词法作用域能够访问foo()的内部作用域  
然后将bar()函数本身作为一个值传递  
foo()执行后，其返回值也就是内部的bar()函数，赋值给变量baz并调用baz，实际只是通过不同的标识符引用了内部的函数bar()。  

>无论通过什么方式对函数类型的值进行值传递，当函数在别处调用时都可以看到闭包。  
内部函数传递到所在的词法作用域之外，它都持有对原始定义作用域的引用，无论在何处执行，都会用闭包！

>如果将函数当作第一级的值并传递，在定时器，事件监听器，ajax请求，跨窗口通信，web workers或其他任何的异步（或同步）任务中，只要使用了回调函数，就是在使用闭包。

### 循环与闭包
for循环中有最常见的闭包问题
```
for(var i=1;i<=5;i++){
    setTimeout(function timer(){
        console.log(i);
    },i*1000);
}
//会每隔1s输出一个6
```
如果要输出1-5
```
for(var i=1;i<=5;i++){
    (function(j){
        setTimeout(function timer(){
        console.log(j)
        },1000*j)
    })(i);   
}
```
ES6后，用let即可解决问题
```
for(let i=1;i<=5;i++){
    setTimeout(function(){
        console.log(i);
    },1000*i);
}
```
### 模块
```
function Cool(){
    var something = "cool";
    function doSomething(){
        console.log(something);
    }
    
    return{
        doSomenthing:doSomething
    };
}
```
>Cool是一个函数，需要调用它来创建一个模块实例  
不执行外部函数，内部作用于和闭包都无法创建  
Cool返回一个对象字面量语法标识的对象  
这个返回的对象中含有对内部函数而不是内部数据变量的引用  
这样就保持了内部数据变量是隐藏且私有的  
将这个对象类型的返回值看作是 模块的公共API
```
var foo = Cool();
foo.doSomenthing;//Cool
```
>对象类型的返回值最终赋值给了foo，foo就可以用来访问API的属性方法  
jquery和$标识符就是jQuery模块的公共API，他们本身就是函数
doSomenthing()具有涵盖模块实例内部作用域的闭包

模块的必要条件
1. 必须有外部的封闭函数，且至少被调用一次（每次调用就创建一个新的模块实例）
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态

>模块创建器（如上面的Cool），可以调用任意多次
只需要一个实例时，就是单例模式  
把模块函数变成IIFE即可实现  
```
var foo=(function Cool(){
    //...
})();
foo.dosomenthin();
```
>模块也可以接收参数
```
funciton Cool(id){
    //...
}
var foo = Cool('aaa');
```

#### ES6模块
>把文件当作独立的模块来处理，每个模块都可以导入其他模块或特定的API成员，同样也可以导出自己的API成员。  

>基于函数的模块不是一个能被静态识别的模式（编译器无法识别他们），它们的语义只有在运行时才会被考虑进来。因此可以在运行时修改一个模块的API

>ES6的模块是静态的，运行时不会改变，因此可以在编译期就检查对导入模块的API成员的引用是否真实存在，如果API引用并不存在，编译器就会在编译时抛出“早期”错误。

>ES6的模块没有行内模式，必须定义在独立的文件中，即一个模块一个文件。
export 和 import



# 附录
try/catch性能很差，
IIFE与try/catch并不是完全等价的，将一段代码用函数进行包裹，会改变这段代码的含义，其中的this,return,break,continue都会变化。  
google维护着一个Traceur的项目，把Es6代码换成兼容ES6之前的环境。